---
layout: post
title:  "자바 메모리 구조"
date:   2020-05-29 08:00:24 +0800
categories: 자바
tags: [자바]
comments: false
---

> 자바 메모리 구조

## Java
자바 프로그램은 JVM(java visual machine)이라는 프로그램 위에서 실행되며, JVM은 프로세스이며, JVM이 OS에게  
메모리를 할당 받아 JVM이 자바 프로그램이 실행한다.  




## JVM 메모리 구조

1. Class Loader
.class 파일들을 엮어서 JVM 메모리 영역인 Runtime Data Area로 적재하는 역할을 이 Class Loader가 한다.

2. Execution Engine
Class Loader에 의해 메모리에 적재된 클래스들을 기계어로 변경해 명령어 단위로 실행하는 역할을 한다.  
명령어를 하나 하나 실행하는 인터프리터 방식이 있고 JIT(Just-in-time) 컴파일러를 이용하는 방식이 있다.
JIT 컴파일러는 적절한 시간에 전체 바이트 코드를 네이티브 코드로 변경해서 Execution Engine이 네이티브로 컴파일된 코드를  
실행하는 것으로 성능을 높이는 방식이다.

3. Garbage Collector
GC는 Heap 메모리 영역에서 생성된 객체들 중에 참조되지 않은 객체들을 탐색 후 제거하는 역할을 한다.  
GC가 역할을 하는 시간은 정확히 언제인지를 알 수 없다.  
또 다른 특징은 GC가 수행되는 동안 GC를 수행하는 쓰레드가 아닌 다른 스레드가 일시정지 된다.
특히 Full GC가 일어나서 수 초간 모든 스레드가 정지한다면 장애로 이어지는 치명적인 문제가 생길 수 있는 것이다.

4. Runtime Data Area
JVM 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다.



1. Method Area
- 클래스 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보같은 필드 정보와 메소드의 이름, 리턴타입, 파라미터, 접근제어자  
정보 같은 메소드정보, Type정보, Constans Pool (상수 풀 : 문자 상수, 타입, 필드, 객체 참조가 저장됨),static 변수, final class 변수 등이 생성되는 영역이다.

1. Heap Area
- new 키워드로 생성된 객체와 배열이 생성되는 영역이다. 메소드 영역에 로드도니 클래스만 생성이 가능하고 GC가 참조되지 않는 메모리를 확인하고 제거하는 영역이다.

1. Stack Area
- 지역변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값등이 생성되는 영역이다.
int a = 10 이라는 소스를 작성했다면 정수값이 할당될 수 있는 메모리공간을 a라고 잡아두고 그 메모리 영역에 값이 10이 들어간다. 
즉, 스택에 메모리에 이름이 a라고 붙여주고 값이 10인 메모리 공간을 만든다.
클래스 Person p = new Person() 이라는 소스를 작성했다면 Person p는 스택영역에 들어가고 new Person() 클래스의 인스턴스는 힙 영역에 생성된다.
그리고 스택영역에 생성된 p의 값으로 힙 영역의 주소값을 가지고 있다. 즉, 스택 영역에 생성된 p가 힙 영역에 생성된 객체를 가리키고(참조하고) 있는 것이다.
메소드를 호출할때 마다 개별적으로 스택이 생성된다.

1. PC Register
- Thread가 생성될 때마다 생성되는 영역으로 Program Counter 즉 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역이다. 
이것을 이용해서 쓰레드를 돌아가면서 수행할 수 있게 한다.

1. Native Method Stack
- 자바외 언어로 작성된 네이티브 코드를 위한 메모리 영역이다.
보통 C/C++등의 코드를 수행하기 위한 스택이다.
JNI 같은거  


쓰레드가 생성되었을때 기준으로 메소드 영역과 힙 영역을 모든 쓰레드가 공유하고, 스택영역과 PC레지스터,네이티브메소드스택은 각각의 쓰레드마다 생성되고 공유되지 않는다.


## Heap Area
힙 영역을 좀 더 살펴봐야 하는데 그 이유는 GC의 주요 대상이기 때문이다. (Stack과 Heap영역도 GC의 대상이 된다.)
힙 영역은 우선 5개의 영역으로 나누어진다.
- eden
- survivor1
- survivor2
- old
- permanent (JDK7까지는 permanent이 heap에 존재했습니다. JDK8부터는 permanent 영역은 사라지고 일부가 "meta space"영역으로 변경되었습니다.)  

힙을 5개로 나눈 이유는 효율적으로 GC가 일어나게 하기 위함이다.  
GC는 Minor GC와 Major GC로 나뉜다.  
  
Minor GC : new 영역에서 일어나는 GC
1. 최초에 객체가 생성되면 Eden영역에 생성된다.
2. Eden영역에 객체가 가득차게 되면 첫 번째 GC가 일어난다.
3. survivor1 영역에 Eden 영역의 메모리를 그대로 복사한다. 그리고 survivor1 영역을 제외한 다른 영역의 객체를 제거한다.
4. Eden영역도 가득차고 survivor1영역도 가득차게 된다면, Eden 영역에 생성된 객체와 survivor1영역에 생성된 객체 중에 참조되고 있는 객체가 있는지 검사한다.
5. 참조 되고 있지 않은 객체는 내버려두고 참조되고 있는 객체만 survivor2영역에 복사한다.
6. survivor2영역을 제외한 다른 영역의 객체들을 제거한다.
7. 위의 과정중에 일정 횟수이상 참조되고 있는 객체들을 survivor2에서 old영역으로 이동시킨다.  
위의 과정을 계속 반복, survivor2영역까지 꽉차기 전에 계속해서 old로 비움  
  
Major GC(Full GC) : Old영역에서 일어난 GC
1. Old 영역에 있는 모든 객체들을 검사하며 참조되고 있는지 확인한다.
2. 참조되지 않은 객체들을 모아 한 번에 제거한다.
- Minor GC보다 시간이 훨씬 많이 걸리고 실행중에 GC를 제외한 모든 쓰레드가 중지한다.
- Full GC가 일어나면 Old영역에 있는 참조가 없는 객체들을 표시하고 그 해당 객체들을 모두 제거하게 된다. 그러면서 Heap메모리 영역에 중간중간 구멍이 생기게 되는데  
이 부분을 없애기 위해 재구성을 한다.(디스크조각모음처럼 조각나 메모리를 정리함)
따라서 메모리를 옮기고 있는데 다른 쓰레드가 메모리를 사용해 버리면 안되기 때문에 모든 쓰레드가 정지하게 되는 것이다.












